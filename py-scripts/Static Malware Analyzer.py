# author: Cyber Assassin
# version: 1.0
# date: 2025-05-29
# description: Static Malware Analyzer


#!/usr/bin/env python3

import os
import hashlib
import re
import datetime
import math
import json
from collections import Counter
import warnings
import tempfile
import shutil
import subprocess
import argparse
import traceback

# --- Matplotlib Configuration for Server-Side Execution ---
import matplotlib
matplotlib.use('Agg') # Use Agg backend for non-interactive plotting (MUST be before pyplot import)
import matplotlib.pyplot as plt
# --- End Matplotlib Configuration ---

# Attempt to import necessary libraries and provide guidance if they are missing
try:
    import magic
except ImportError:
    magic = None

try:
    import pefile
except ImportError:
    pefile = None

try:
    from elftools.elf.elffile import ELFFile
    from elftools.elf.sections import SymbolTableSection
except ImportError:
    ELFFile = None
    SymbolTableSection = None

try:
    from androguard.core.bytecodes.apk import APK
    from androguard.core.analysis.analysis import Analysis
except ImportError:
    APK = None
    Analysis = None

try:
    import ssdeep
except ImportError:
    ssdeep = None

try:
    from oletools import olevba, oleid
except ImportError:
    olevba = None
    oleid = None

try:
    import pypdfium2 as pdfium
except ImportError:
    pdfium = None

try:
    from scipy.stats import entropy as scipy_entropy
except ImportError:
    scipy_entropy = None


# --- Configuration for Highlighting ---
SUSPICIOUS_APIS = [
    "CreateRemoteThread", "WriteProcessMemory", "ReadProcessMemory", "VirtualAllocEx",
    "VirtualProtectEx", "OpenProcess", "ResumeThread", "SetThreadContext",
    "NtQueueApcThread", "ZwQueueApcThread", "socket", "connect", "send", "recv",
    "InternetOpenA", "InternetOpenUrlA", "HttpSendRequestA", "InternetReadFile",
    "URLDownloadToFileA", "CreateFileA", "WriteFile", "ReadFile", "DeleteFileA",
    "RegCreateKeyExA", "RegSetValueExA", "RegOpenKeyExA", "ShellExecuteA",
    "CreateProcessA", "WinExec", "CryptEncrypt", "CryptDecrypt", "CryptGenKey",
    "CryptImportKey", "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "GetTickCount",
    "OutputDebugStringA", "FindWindowA", "GetForegroundWindow", "Sleep",
    "SetWindowsHookExA", "GetAsyncKeyState", "GetKeyState"
]

DANGEROUS_APK_PERMISSIONS = [
    "android.permission.SEND_SMS", "android.permission.RECEIVE_SMS", "android.permission.READ_SMS",
    "android.permission.CALL_PHONE", "android.permission.PROCESS_OUTGOING_CALLS",
    "android.permission.READ_CALL_LOG", "android.permission.WRITE_CALL_LOG",
    "android.permission.INSTALL_PACKAGES", "android.permission.REQUEST_INSTALL_PACKAGES",
    "android.permission.ACCESS_FINE_LOCATION", "android.permission.ACCESS_COARSE_LOCATION",
    "android.permission.CAMERA", "android.permission.RECORD_AUDIO",
    "android.permission.READ_CONTACTS", "android.permission.WRITE_CONTACTS",
    "android.permission.GET_ACCOUNTS", "android.permission.READ_EXTERNAL_STORAGE",
    "android.permission.WRITE_EXTERNAL_STORAGE", "android.permission.MANAGE_EXTERNAL_STORAGE",
    "android.permission.SYSTEM_ALERT_WINDOW", "android.permission.BIND_DEVICE_ADMIN",
    "android.permission.PACKAGE_USAGE_STATS", "android.permission.BIND_ACCESSIBILITY_SERVICE"
]

COMMON_MALWARE_KEYWORDS = [
    "payload", "exploit", "trojan", "virus", "worm", "backdoor", "rootkit",
    "keylogger", "spyware", "ransom", "botnet", "c2", "cnc", "malware",
    "hack", "inject", "shellcode", "dropper", "downloader", "obfuscate",
    "encrypt", "decrypt", "steal", "password", "credential"
]

# --- Helper Functions ---
def get_file_size(file_path):
    size_bytes = os.path.getsize(file_path)
    if size_bytes < 1024: return f"{size_bytes} bytes"
    elif size_bytes < 1024**2: return f"{size_bytes/1024:.2f} KB"
    elif size_bytes < 1024**3: return f"{size_bytes/1024**2:.2f} MB"
    else: return f"{size_bytes/1024**3:.2f} GB"

def calculate_hashes(file_path):
    hashes = {}
    try:
        with open(file_path, 'rb') as f:
            file_data = f.read()
            hashes['md5'] = hashlib.md5(file_data).hexdigest()
            hashes['sha1'] = hashlib.sha1(file_data).hexdigest()
            hashes['sha256'] = hashlib.sha256(file_data).hexdigest()
            if ssdeep:
                try: hashes['ssdeep'] = ssdeep.hash(file_data)
                except Exception as e: hashes['ssdeep'] = f"Error: {e}"
            else: hashes['ssdeep'] = "N/A (library missing)"
    except Exception as e: return {"error": f"Hash read error: {e}"}
    return hashes

def get_file_type(file_path):
    if not magic: return "N/A (library missing)"
    try: return magic.from_file(file_path)
    except Exception as e: return f"File type error: {e}"

def calculate_entropy(data):
    if not data: return 0.0
    if scipy_entropy:
        counts = Counter(data)
        probabilities = [count / len(data) for count in counts.values()]
        return scipy_entropy(probabilities, base=2)
    else:
        byte_counts = Counter(data)
        entropy_val = 0.0
        data_len = float(len(data))
        for count in byte_counts.values():
            freq = count / data_len
            entropy_val -= freq * math.log2(freq)
        return entropy_val

def extract_strings(file_path, min_len=4):
    strings = {"ascii": [], "unicode": [], "highlighted": []}
    ip_pattern = re.compile(r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b')
    url_pattern = re.compile(r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+[/\w\d_?=-]*')
    domain_pattern = re.compile(r'\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}\b')
    registry_key_pattern = re.compile(r'(?:HKLM|HKCU|HKEY_LOCAL_MACHINE|HKEY_CURRENT_USER)\\[\w\\\s.-]+', re.IGNORECASE)
    try:
        with open(file_path, 'rb') as f: data = f.read()
        for match in re.finditer(b"[\x20-\x7E]{%d,}" % min_len, data):
            s = match.group(0).decode('ascii', errors='ignore')
            strings["ascii"].append(s)
            if any(k.lower() in s.lower() for k in COMMON_MALWARE_KEYWORDS) or \
               ip_pattern.search(s) or url_pattern.search(s) or domain_pattern.search(s) or \
               registry_key_pattern.search(s):
                strings["highlighted"].append(f"(ASCII) {s}")
        for match in re.finditer(b"(?:[\x20-\x7E]\x00){%d,}" % min_len, data):
            try:
                s = match.group(0).decode('utf-16le', errors='ignore')
                strings["unicode"].append(s)
                if any(k.lower() in s.lower() for k in COMMON_MALWARE_KEYWORDS) or \
                   ip_pattern.search(s) or url_pattern.search(s) or domain_pattern.search(s) or \
                   registry_key_pattern.search(s):
                    strings["highlighted"].append(f"(Unicode) {s}")
            except UnicodeDecodeError: continue
    except Exception as e: strings["error"] = f"String extraction error: {e}"
    return strings

# --- Enhanced Plotting Functions ---
def visualize_overall_file_entropy(file_path, original_filename=None, block_size=256):
    """Visualizes overall file entropy block by block with a dark theme."""
    if not plt or not scipy_entropy:
        return "Plotting libraries (matplotlib, scipy) not found."
    
    plt.style.use('dark_background') # Apply dark theme
    entropies = []
    
    # Use original filename if provided, otherwise extract from path
    if original_filename is None:
        original_filename = os.path.basename(file_path)
    
    # --- CHANGE: Use environment variable for plots directory, default to ./plots ---
    plots_dir = os.environ.get('PLOTS_DIR', './plots')
    os.makedirs(plots_dir, exist_ok=True) # Create the directory if it doesn't exist
    plot_path = os.path.join(plots_dir, f"{original_filename}_overall_entropy.png")
    # --- END CHANGE ---

    try:
        with open(file_path, 'rb') as f:
            while True:
                block = f.read(block_size)
                if not block: break
                entropies.append(calculate_entropy(block))

        fig, ax = plt.subplots(figsize=(15, 7)) # Larger figure size
        ax.plot(entropies, color='cyan', linewidth=1.5)
        ax.set_title(f"Overall File Entropy: {original_filename}\n(Block Size: {block_size} bytes)", fontsize=16, color='white')
        ax.set_xlabel("Block Number", fontsize=12, color='lightgray')
        ax.set_ylabel("Shannon Entropy (bits)", fontsize=12, color='lightgray')
        ax.set_ylim(0, 8)
        ax.grid(True, linestyle='--', alpha=0.5, color='gray')
        ax.tick_params(colors='lightgray') # Color for ticks and labels

        plt.tight_layout() # Adjust layout to prevent clipping
        plt.savefig(plot_path)
        plt.close(fig) # Close the figure to free memory
        return f"Plot successfully generated at: {plot_path}"
    except Exception as e:
        return f"Failed to generate plot: {str(e)}"

def visualize_section_entropies(sections_data, file_basename, file_type_label):
    """Visualizes entropy of different sections (e.g., in PE/ELF files)."""
    if not plt or not sections_data:
        return "Plotting library (matplotlib) not found or no section data."

    plt.style.use('dark_background')
    
    # --- CHANGE: Use environment variable for plots directory, default to ./plots ---
    plots_dir = os.environ.get('PLOTS_DIR', './plots')
    os.makedirs(plots_dir, exist_ok=True) # Create the directory if it doesn't exist
    plot_path = os.path.join(plots_dir, f"{file_basename}_{file_type_label}_section_entropy.png")
    # --- END CHANGE ---

    try:
        # Sort sections by entropy for better visualization
        sections_data.sort(key=lambda x: x['entropy'])
        
        names = [s['name'] for s in sections_data]
        entropies = [s['entropy'] for s in sections_data]
        
        fig, ax = plt.subplots(figsize=(12, 8))
        
        bars = ax.barh(names, entropies, color='skyblue')
        
        ax.set_xlabel('Shannon Entropy (bits)', color='lightgray')
        ax.set_ylabel('Section Name', color='lightgray')
        ax.set_title(f'{file_type_label} Section Entropy for {file_basename}', color='white')
        ax.tick_params(colors='lightgray')
        ax.grid(True, linestyle='--', alpha=0.3, axis='x')
        
        # Add entropy values on the bars
        for bar in bars:
            ax.text(bar.get_width() + 0.1, bar.get_y() + bar.get_height()/2, 
                    f'{bar.get_width():.2f}', 
                    va='center', ha='left', color='cyan')
        
        plt.tight_layout()
        plt.savefig(plot_path)
        plt.close(fig)
        return f"Plot successfully generated at: {plot_path}"
    except Exception as e:
        return f"Failed to generate section plot: {str(e)}"

# --- Analysis Functions (PE, ELF, APK, Office, PDF - mostly unchanged, but will call new plot functions) ---
def analyze_pe(file_path, original_filename=None):
    if not pefile: return {"error": "pefile library not available"}
    pe_info = {"architecture": "Unknown"}
    
    # Use original filename if provided, otherwise extract from path
    if original_filename is None:
        original_filename = os.path.basename(file_path)
    
    try:
        pe = pefile.PE(file_path, fast_load=True)
        if pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE['IMAGE_FILE_MACHINE_I386']: pe_info['architecture'] = "32-bit"
        elif pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE['IMAGE_FILE_MACHINE_AMD64']: pe_info['architecture'] = "64-bit"
        elif pe.FILE_HEADER.Machine == pefile.MACHINE_TYPE['IMAGE_FILE_MACHINE_IA64']: pe_info['architecture'] = "IA-64"
        timestamp = pe.FILE_HEADER.TimeDateStamp
        pe_info['compile_timestamp'] = datetime.datetime.fromtimestamp(timestamp, datetime.UTC).strftime('%Y-%m-%d %H:%M:%S UTC')
        pe_info['entry_point'] = hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint)
        if hasattr(pe, 'RICH_HEADER') and pe.RICH_HEADER:
            pe_info['rich_header_info'] = str(pe.RICH_HEADER.values) if hasattr(pe.RICH_HEADER, 'values') else \
                                          [{"comp_id": hex(r[0]>>16|r[1]&0xFFFF0000), "product_id": hex(r[0]&0xFFFF), "count":r[1]&0xFFFF} for r in pe.RICH_HEADER.records]
        pe_info['sections'] = []
        sections_for_plot = []
        for section in pe.sections:
            sec_name = section.Name.decode().rstrip('\x00')
            sec_data = section.get_data()
            sec_entropy = calculate_entropy(sec_data)
            sec_entry = {
                'name': sec_name, 'virtual_address': hex(section.VirtualAddress),
                'virtual_size': section.Misc_VirtualSize, 'raw_size': section.SizeOfRawData,
                'characteristics': hex(section.Characteristics), 'entropy': f"{sec_entropy:.2f}"
            }
            pe_info['sections'].append(sec_entry)
            sections_for_plot.append({'name': sec_name, 'entropy': sec_entropy}) # For plotting
        
        # Generate PE section entropy plot using original filename
        pe_info['section_entropy_plot'] = visualize_section_entropies(sections_for_plot, original_filename, "PE")

        pe_info['imports'] = {}; pe_info['suspicious_imports'] = []
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode(); pe_info['imports'][dll_name] = []
                for imp in entry.imports:
                    func_name = imp.name.decode() if imp.name else f"Ordinal {imp.ordinal}"
                    pe_info['imports'][dll_name].append(func_name)
                    if func_name in SUSPICIOUS_APIS: pe_info['suspicious_imports'].append(f"{dll_name} -> {func_name}")
        pe_info['exports'] = []
        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                pe_info['exports'].append(exp.name.decode() if exp.name else f"Ordinal {exp.ordinal}")
        pe_info['resources'] = []
        if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
            for r_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                t_name = pefile.RESOURCE_TYPE.get(r_type.id, str(r_type.id))
                for r_id in r_type.directory.entries:
                    id_name = str(r_id.name) if r_id.name else str(r_id.id)
                    for r_lang in r_id.directory.entries:
                        pe_info['resources'].append({
                            "type": t_name, "id": id_name, "language": f"{r_lang.data.lang}-{r_lang.data.sublang}",
                            "offset": hex(r_lang.data.struct.OffsetToData), "size": r_lang.data.struct.Size
                        })
        pe_info['digital_signature'] = "Present (further parsing needed)" if hasattr(pe, 'DIRECTORY_ENTRY_SECURITY') and pe.DIRECTORY_ENTRY_SECURITY else "Not Present"
        pe_info['packer_detection'] = [p for p in ["UPX", "ASPack"] if any(s.Name.startswith(p.encode()) for s in pe.sections)]
    except pefile.PEFormatError as e: pe_info['error'] = f"PE Format Error: {e}"
    except Exception as e: pe_info['error'] = f"PE Analysis Error: {e}"
    return pe_info

def analyze_elf(file_path, original_filename=None):
    if not ELFFile or not SymbolTableSection: return {"error": "pyelftools library not available"}
    elf_info = {}
    
    # Use original filename if provided, otherwise extract from path
    if original_filename is None:
        original_filename = os.path.basename(file_path)
    
    try:
        with open(file_path, 'rb') as f:
            elffile = ELFFile(f)
            elf_info['architecture'] = elffile.get_machine_arch()
            elf_info['entry_point'] = hex(elffile.header['e_entry'])
            elf_info['sections'] = []; sections_for_plot = []
            for section in elffile.iter_sections():
                sec_name = section.name
                sec_data = section.data()
                sec_entropy = calculate_entropy(sec_data) if len(sec_data) < 2*1024*1024 else "Data too large"
                sec_entry = {
                    'name': sec_name, 'type': section['sh_type'], 'size': section['sh_size'],
                    'flags': section['sh_flags'], 'entropy': f"{sec_entropy:.2f}" if isinstance(sec_entropy, float) else sec_entropy
                }
                elf_info['sections'].append(sec_entry)
                if isinstance(sec_entropy, float): sections_for_plot.append({'name': sec_name, 'entropy': sec_entropy})

            elf_info['section_entropy_plot'] = visualize_section_entropies(sections_for_plot, original_filename, "ELF")
            
            elf_info['segments'] = []
            for segment in elffile.iter_segments():
                elf_info['segments'].append({
                    'type': segment['p_type'], 'offset': hex(segment['p_offset']),
                    'virtual_address': hex(segment['p_vaddr']), 'physical_address': hex(segment['p_paddr']),
                    'file_size': segment['p_filesz'], 'memory_size': segment['p_memsz'], 'flags': segment['p_flags']
                })
            elf_info['imported_symbols'] = []; elf_info['exported_symbols'] = []
            for section in elffile.iter_sections():
                if isinstance(section, SymbolTableSection):
                    for symbol in section.iter_symbols():
                        if symbol['st_shndx'] == 'SHN_UNDEF': elf_info['imported_symbols'].append(symbol.name)
                        elif symbol['st_info']['bind'] in ['STB_GLOBAL', 'STB_WEAK'] and symbol['st_shndx'] != 'SHN_UNDEF':
                            elf_info['exported_symbols'].append(symbol.name)
            elf_info['imported_symbols'] = list(set(elf_info['imported_symbols']))
            elf_info['exported_symbols'] = list(set(elf_info['exported_symbols']))
    except Exception as e: elf_info['error'] = f"ELF Analysis Error: {e}"
    return elf_info

def analyze_apk(file_path):
    if not APK or not Analysis: return {"error": "androguard library not available"}
    apk_info = {}
    try:
        a = APK(file_path)
        apk_info['package_name'] = a.get_package(); apk_info['app_name'] = a.get_app_name()
        apk_info['version_code'] = a.get_androidversion_code(); apk_info['version_name'] = a.get_androidversion_name()
        apk_info['permissions'] = a.get_permissions()
        apk_info['dangerous_permissions_found'] = [p for p in apk_info['permissions'] if p in DANGEROUS_APK_PERMISSIONS]
        apk_info['activities'] = a.get_activities(); apk_info['services'] = a.get_services()
        apk_info['receivers'] = a.get_receivers(); apk_info['providers'] = a.get_providers()
        apk_info['main_activity'] = a.get_main_activity()
        certs = a.get_certificates_der_v3()
        apk_info['certificate_info'] = [f"Cert {i+1} (DER len: {len(c)})" for i,c in enumerate(certs)] if certs else "No certs"
        apk_info['files_in_apk'] = a.get_files()[:20]
        if len(a.get_files()) > 20: apk_info['files_in_apk'].append(f"... and {len(a.get_files()) - 20} more.")
    except Exception as e: apk_info['error'] = f"APK Analysis Error: {e}"
    return apk_info

def analyze_office_doc(file_path):
    doc_info = {}
    if not olevba or not oleid:
        doc_info["error"] = "oletools not available."
        if file_path.lower().endswith(('.docx', '.xlsx', '.pptx')):
            import zipfile
            try:
                with zipfile.ZipFile(file_path, 'r') as zf:
                    doc_info["files_in_zip"] = zf.namelist()[:10]
                    doc_info["macro_detection"] = "vbaProject.bin found" if any("vbaProject.bin" in n for n in zf.namelist()) else "vbaProject.bin not found"
            except Exception as e: doc_info["zip_error"] = str(e)
        return doc_info
    try:
        oid_parser = oleid.OleID(file_path); indicators = oid_parser.check()
        doc_info['oleid_indicators'] = [{"id": i.id, "type": i.type, "value": str(i.value), "desc": i.description} for i in indicators]
        vba_parser = olevba.VBA_Parser(file_path)
        if vba_parser.detect_vba_macros():
            doc_info['macro_detection'] = "VBA Macros Detected"
            doc_info['vba_extracted_macros_summary'] = [{"file":f,"stream":s,"vba_file":v} for f,s,v,_ in vba_parser.extract_macros()]
            vba_parser.analyze_macros()
            doc_info['vba_macro_analysis'] = [{"type":t,"keyword":k,"desc":d} for t,k,d in vba_parser.analysis]
        else: doc_info['macro_detection'] = "No VBA Macros Detected by olevba"
    except Exception as e: doc_info['error'] = f"Office Doc Analysis Error: {e}"
    return doc_info

def analyze_pdf(file_path):
    pdf_info = {}
    if not pdfium: return {"error": "pypdfium2 library not available."}
    try:
        pdf = pdfium.PdfDocument(file_path)
        pdf_info['version'] = pdf.version; pdf_info['page_count'] = len(pdf)
        pdf_info['javascript_detection'] = "Needs deeper inspection"; pdf_info['embedded_files_detection'] = "Needs deeper inspection"
        pdf_info['open_action_check'] = "Needs deeper inspection"
        pdf.close()
    except Exception as e: pdf_info['error'] = f"PDF Analysis Error: {e}"
    return pdf_info

# --- Main Analysis Function ---
def static_analyze_file(file_path, original_filename=None):
    # File size check: reject if <1KB or >25MB
    min_size = 1024
    max_size = 25 * 1024 * 1024
    try:
        size = os.path.getsize(file_path)
        if size < min_size or size > max_size:
            return {"error": "file size isn't suitable"}
    except Exception as e:
        return {"error": f"file size check failed: {e}"}
    
    if not os.path.exists(file_path): return {"error": f"File not found: {file_path}"}
    
    # Use original filename if provided, otherwise extract from path
    if original_filename is None:
        original_filename = os.path.basename(file_path)
    
    analysis_results = {}
    analysis_results['file_identification'] = {
        'file_name': original_filename, 'file_path': os.path.abspath(file_path),
        'file_size': get_file_size(file_path), 'file_type_magic': get_file_type(file_path),
        'hashes': calculate_hashes(file_path), 'architecture': "Unknown"
    }
    analysis_results['string_analysis'] = extract_strings(file_path)
    
    # Overall File Entropy Calculation & Plot
    try:
        with open(file_path, 'rb') as f_full: full_data = f_full.read()
        overall_entropy_val = calculate_entropy(full_data)
        analysis_results['overall_file_entropy'] = {
            "value": f"{overall_entropy_val:.2f}",
            "remark": "High (suggests packing/encryption)" if overall_entropy_val > 7.0 else "Normal/Low"
        }
    except Exception as e: analysis_results['overall_file_entropy'] = {"error": str(e)}
    
    # Generate plot using original filename
    visualize_overall_file_entropy(file_path, original_filename)

    file_type_desc = analysis_results['file_identification']['file_type_magic'].lower()
    if "pe32" in file_type_desc or ("executable" in file_type_desc and "windows" in file_type_desc):
        if pefile:
            pe_results = analyze_pe(file_path, original_filename)
            if 'section_entropy_plot' in pe_results:
                del pe_results['section_entropy_plot']
            analysis_results['pe_analysis'] = pe_results
            if 'architecture' in pe_results: analysis_results['file_identification']['architecture'] = pe_results['architecture']
            if 'rich_header_info' in pe_results and pe_results['rich_header_info']:
                 analysis_results['file_identification']['compiler_linker_info_heuristic'] = "See PE Rich Header"
    elif "elf" in file_type_desc:
        if ELFFile:
            elf_results = analyze_elf(file_path, original_filename)
            if 'section_entropy_plot' in elf_results:
                del elf_results['section_entropy_plot']
            analysis_results['elf_analysis'] = elf_results
            if 'architecture' in elf_results: analysis_results['file_identification']['architecture'] = elf_results['architecture']
    elif "zip archive" in file_type_desc and (".apk" in file_path.lower() or "android" in file_type_desc):
        if APK: analysis_results['apk_analysis'] = analyze_apk(file_path)
    elif any(ft in file_type_desc for ft in ["microsoft office", "microsoft word", "microsoft excel", "microsoft powerpoint"]) or \
         file_path.lower().endswith(('.doc', '.xls', '.ppt', '.docx', '.xlsx', '.pptx', '.docm', '.xlsm', '.pptm')):
        analysis_results['office_document_analysis'] = analyze_office_doc(file_path)
    elif "pdf document" in file_type_desc:
        analysis_results['pdf_analysis'] = analyze_pdf(file_path)
    
    return analysis_results

def print_analysis_results(results):
    print(json.dumps(results, indent=4, sort_keys=False))

# --- Main Execution ---
if __name__ == "__main__":
    #print("STATIC MALWARE ANALYZER STARTED", flush=True)
    import sys
    #print("ARGS:", sys.argv, flush=True)
    import mimetypes
    import traceback
    try:
        def is_archive(filename):
            return any(filename.lower().endswith(ext) for ext in ['.zip', '.rar', '.7z'])

        def extract_archive(file_path, extract_dir, password=None, original_filename=None):
            ext = os.path.splitext(original_filename or file_path)[1].lower()
            if ext in ['.rar']:
                # Use unrar for .rar files
                cmd = ['unrar', 'x']
                if password:
                    cmd.append(f'-p{password}')
                else:
                    cmd.append('-p-')  # No password
                cmd.extend([file_path, extract_dir])
            elif ext in ['.7z', '.7r', '.zip']:
                # Use 7z for other supported archive types
                cmd = ['7z', 'x']
                if password:
                    cmd.append(f'-p{password}')
                cmd.extend(['-y', file_path, f'-o{extract_dir}'])
            else:
                return False, f"Unsupported archive format: {ext}"
            proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            return proc.returncode == 0, proc.stderr.decode('utf-8') or proc.stdout.decode('utf-8')

        parser = argparse.ArgumentParser()
        parser.add_argument('target_file')
        parser.add_argument('original_filename', nargs='?')
        parser.add_argument('password', nargs='?')
        parser.add_argument('--keep-extracted', action='store_true', help='Keep extracted files after analysis')
        args = parser.parse_args()

        target_file = args.target_file
        original_filename = args.original_filename
        password = args.password
        keep_extracted = args.keep_extracted

        results = []

        def get_plot_paths(filename):
            plots_dir = os.environ.get('PLOTS_DIR', './plots')
            base = os.path.splitext(filename)[0]
            plot_files = [
                f"{filename}_overall_entropy.png",
                f"{filename}_PE_section_entropy.png",
                f"{filename}_ELF_section_entropy.png"
            ]
            return [os.path.join(plots_dir, pf) for pf in plot_files if os.path.exists(os.path.join(plots_dir, pf))]

        if is_archive(original_filename or target_file):
            # Extract archive to temp dir
            temp_dir = tempfile.mkdtemp(prefix="malware_extract_")
            try:
                success, error = extract_archive(target_file, temp_dir, password, original_filename)
                if not success:
                    # Improved: Detect wrong password and output specific error
                    err_lower = error.lower()
                    if "wrong password" in err_lower or "incorrect password" in err_lower or "password is incorrect" in err_lower:
                        print(json.dumps({"error": "password is wrong "}))
                    else:
                        print(json.dumps({"error": f"Extraction failed: {error}"}))
                    if not keep_extracted:
                        shutil.rmtree(temp_dir)
                    sys.exit(2)
                # Recursively find all files in temp_dir
                for root, dirs, files in os.walk(temp_dir):
                    for file in files:
                        file_path = os.path.join(root, file)
                        result = static_analyze_file(file_path, file)
                        plots = get_plot_paths(file)
                        results.append({
                            "filename": file,
                            "file_path": file_path,
                            "analysis": result,
                            "plots": plots
                        })
                print(json.dumps({"results": results}))
                sys.exit(0)
            finally:
                if not keep_extracted:
                    shutil.rmtree(temp_dir)
        else:
            result = static_analyze_file(target_file, original_filename)
            plots = get_plot_paths(original_filename or os.path.basename(target_file))
            print(json.dumps({"results": [{
                "filename": original_filename or os.path.basename(target_file),
                "file_path": target_file,
                "analysis": result,
                "plots": plots
            }]}))
            sys.exit(0)
    except Exception as e:
        print(json.dumps({"error": f"Unhandled exception: {str(e)}", "traceback": traceback.format_exc()}))
        sys.exit(2)


